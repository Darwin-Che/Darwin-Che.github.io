

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algebra Algorithms &mdash; Zhaocheng Che&#39;s Blog 2025-11-26 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3d3e70f0"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Combinatorics Algorithms" href="combinatorics.html" />
    <link rel="prev" title="Algorithms" href="index.html" />     
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Zhaocheng Che's Blog
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Blog</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tech/index.html">Tech Posts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Algorithms</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Algebra Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#binary-exponentiation">Binary Exponentiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#euclidean-algorithm-for-gcd-and-lcm">Euclidean Algorithm for GCD and LCM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extended-euclidean-algorithm-and-linear-diophantine-equations">Extended Euclidean Algorithm and Linear Diophantine Equations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#binet-s-formula">Binet’s formula</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-recursion">Matrix Recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#different-optimizations-of-the-sieve-of-eratosthenes">Different optimizations of the Sieve of Eratosthenes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#segmented-sieve">Segmented Sieve</a></li>
<li class="toctree-l4"><a class="reference internal" href="#find-primes-in-range">Find primes in range</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sieve-of-eratosthenes-having-linear-time-complexity">Sieve of Eratosthenes Having Linear Time Complexity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#correctness-proof">Correctness Proof</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#primality-tests">Primality tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#trial-division">Trial division</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fermat-primality-test">Fermat primality test</a></li>
<li class="toctree-l4"><a class="reference internal" href="#euler-s-theorem">Euler’s Theorem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#find-modulo-inverse">Find Modulo Inverse</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#extended-euclidean-algo">Extended Euclidean Algo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fermat-s-euclid-thm">Fermat’s / Euclid Thm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#find-all-number-s-modulo-inverse-from-1-to-m-in-o-m">Find all number’s modulo inverse from 1 to m in <span class="math notranslate nohighlight">\(O(m)\)</span>​</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#linear-congruence-equation">Linear Congruence Equation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inverse">Inverse</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extended-euclidean-algorithm">Extended Euclidean Algorithm</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#garner-s-algorithm">Garner’s Algorithm</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discrete-logarithm">Discrete Logarithm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-simplest-implementation">The simplest implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#improved-implementation">Improved implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-a-and-m-are-not-coprime">When <em>a</em> and <em>m</em> are not coprime</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#primitive-root">Primitive Root</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#existence">Existence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relation-with-the-euler-function">Relation with the Euler function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computation">Computation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discrete-root">Discrete Root</a></li>
<li class="toctree-l3"><a class="reference internal" href="#montgomery-multiplication">Montgomery Multiplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="combinatorics.html">Combinatorics Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="data_struc.html">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="dp.html">DP</a></li>
<li class="toctree-l2"><a class="reference internal" href="geo_1.html">Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph.html">Graph Algo</a></li>
<li class="toctree-l2"><a class="reference internal" href="linalg.html">Linear Algebra Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="mono_queue.html">Monotonic Queue and similar ideas</a></li>
<li class="toctree-l2"><a class="reference internal" href="string.html">String Processing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../recap/index.html">Recap</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Zhaocheng Che's Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Algorithms</a></li>
      <li class="breadcrumb-item active">Algebra Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/posts/algo/algebra.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
              <section class="tex2jax_ignore mathjax_ignore" id="algebra-algorithms">
<h1>Algebra Algorithms<a class="headerlink" href="#algebra-algorithms" title="Link to this heading"></a></h1>
<section id="binary-exponentiation">
<h2>Binary Exponentiation<a class="headerlink" href="#binary-exponentiation" title="Link to this heading"></a></h2>
<p>Recursive</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">binpow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Iterative</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">binpow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example Problems:</p>
<p>Compute <span class="math notranslate nohighlight">\(x^n \mod m\)</span>​. <span class="math notranslate nohighlight">\(O(\log n)\)</span></p>
<p>Compute <em>n</em>-th Fibonacci number. <span class="math notranslate nohighlight">\(O(\log n)\)</span></p>
<p>Applying a permutation <em>k</em> times <span class="math notranslate nohighlight">\(O(n \log k)\)</span></p>
<p>Number of paths of length <em>k</em> in a graph <span class="math notranslate nohighlight">\(O(n^3 \log k)\)</span>​</p>
</section>
<section id="euclidean-algorithm-for-gcd-and-lcm">
<h2>Euclidean Algorithm for GCD and LCM<a class="headerlink" href="#euclidean-algorithm-for-gcd-and-lcm" title="Link to this heading"></a></h2>
<p>recursive</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">gcd</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">lcm</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Binary ops</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="extended-euclidean-algorithm-and-linear-diophantine-equations">
<h2>Extended Euclidean Algorithm and Linear Diophantine Equations<a class="headerlink" href="#extended-euclidean-algorithm-and-linear-diophantine-equations" title="Link to this heading"></a></h2>
<p>EEA</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">);</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y1</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b1</span><span class="p">;</span>
<span class="w">        </span><span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x1</span><span class="p">);</span>
<span class="w">        </span><span class="n">tie</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y1</span><span class="p">);</span>
<span class="w">        </span><span class="n">tie</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>LDE</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">);</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y1</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">find_any_solution</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">y0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">x0</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">    </span><span class="n">y0</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">x0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">y0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">y0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The set of all possible solutions are</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} x = x_0 + k \frac{b}{g} $$​​\\$$ y = y_0 - k \frac{a}{g} $$​​\\## Fibonacci Numbers\\For the following, $F_0 = 0$, $F_1 = 1$.\\### Properties\\- Cassini's identity\\  $$F_{n-1}F_{n+1} - F_n^2 = (-1)^n$$​​\\- The &quot;addition&quot; rule\\  $$F_{n+k} = F_k F_{n+1} + F_{k-1}F_n\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[F_{2n} = F_n (F_{n+1} + F_{n-1})\]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}F_{nk}$$ is a multiple of $F_n$​, the inverse is also true.\\- GCD\\  $$GCD(F_n, F_m) = F_{GCD(n,m)}\end{aligned}\end{align} \]</div>
<ul>
<li><p>Lame’s Theorem</p>
<p>Fibonacci numbers are the worst possible inputs for Euclidean algorithm.</p>
</li>
</ul>
<section id="binet-s-formula">
<h3>Binet’s formula<a class="headerlink" href="#binet-s-formula" title="Link to this heading"></a></h3>
<div class="math notranslate nohighlight">
\[F_n = \frac{(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n}{\sqrt{5}} = [ \frac{(\frac{1+\sqrt{5}}{2})^n }{\sqrt{5}} ]\]</div>
</section>
<section id="matrix-recursion">
<h3>Matrix Recursion<a class="headerlink" href="#matrix-recursion" title="Link to this heading"></a></h3>
<p>Let <span class="math notranslate nohighlight">\(P = \begin{pmatrix}0 &amp; 1 \\ 1 &amp; 1 \end{pmatrix}\)</span>​, then</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} \begin{pmatrix} F_{n-1} &amp; F_{n} \end{pmatrix} =  \begin{pmatrix} F_{n-2} &amp; F_{n-1}\end{pmatrix} \cdot P$$​​\\$$ \begin{pmatrix} F_n &amp; F_{n+1} \end{pmatrix} =  \begin{pmatrix} F_0 &amp; F_1 \end{pmatrix} \cdot P^n$$​\\### Fast Doubling Method\\$$F_{2k} = F_k \cdot (2F_{k+1} - F_k)\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}F_{2k+1} = F_{k+1}^2 + F_k^2$$​\\```c++
// return F_n, F_{n+1}
pair&lt;int, int&gt; fib (int n) {
    if (n == 0)
        return {0, 1};\\    auto p = fib(n &gt;&gt; 1);
    int c = p.first * (2 * p.second - p.first);
    int d = p.first * p.first + p.second * p.second;
    if (n &amp; 1)
        return {d, c + d};
    else
        return {c, d};
}
```\\Consider the Fibonacci sequence modulo *p*. We will prove the sequence is periodic and the period begins with $F_1 = 1$ (that is, the pre-period contains only $F_0$).\\## Sieve of Eratosthenes\\```c++
int n;
vector&lt;bool&gt; is_prime(n+1, true);
is_prime[0] = is_prime[1] = false;
for (int i = 2; i &lt;= n; i++) {
    if (is_prime[i] &amp;&amp; (long long)i * i &lt;= n) {
        for (int j = i * i; j &lt;= n; j += i)
            is_prime[j] = false;
    }
}
```\\The algorithm will perform $\frac{n}{p}$ operations for each prime $p \le n$. \\So the runtime is $n \cdot \sum \frac{1}{p}$​\\Two helpful facts: \\- The number of prime numbers less than or equal to $n$ is about $\frac{n}{\ln n}$
- The $k$'th prime number is about $k \ln k$\\So $$\sum \frac{1}{p} \approx \frac{1}{2} + \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k}\end{aligned}\end{align} \]</div>
<p>And $<span class="math notranslate nohighlight">\(\sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} \approx \int_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} = \ln \ln \frac{n}{\ln n} - \ln \ln 2 \approx \ln \ln n \)</span>$</p>
</section>
<section id="different-optimizations-of-the-sieve-of-eratosthenes">
<h3>Different optimizations of the Sieve of Eratosthenes<a class="headerlink" href="#different-optimizations-of-the-sieve-of-eratosthenes" title="Link to this heading"></a></h3>
<section id="sieving-till-root">
<h4>Sieving till root<a class="headerlink" href="#sieving-till-root" title="Link to this heading"></a></h4>
<p>The biggest weakness of the algorithm is, that it “walks” along the memory multiple times, only manipulating single elements. This is not very cache friendly.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">is_prime</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sieving-by-the-odd-numbers-only">
<h4>Sieving by the odd numbers only<a class="headerlink" href="#sieving-by-the-odd-numbers-only" title="Link to this heading"></a></h4>
<p>Since all even numbers (except 2) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only.</p>
<p>First, it will allow us to half the needed memory. Second, it will  reduce the number of operations performing by algorithm approximately in half.</p>
</section>
<section id="memory-consumption-and-speed-of-operations">
<h4>Memory consumption and speed of operations<a class="headerlink" href="#memory-consumption-and-speed-of-operations" title="Link to this heading"></a></h4>
<p>We should notice, that these two implementations of the Sieve of Eratosthenes use <em>n</em> bits of memory by using the data structure <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> is not a regular container that stores a series of <code class="docutils literal notranslate"><span class="pre">bool</span></code> (as in most computer architectures a <code class="docutils literal notranslate"><span class="pre">bool</span></code> takes one byte of memory). It’s a memory-optimization specialization of <code class="docutils literal notranslate"><span class="pre">vector&lt;T&gt;</span></code>, that only consumes <em>N</em>8 bytes of memory.</p>
<p>Modern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly. So underneath the <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> stores the bits in a  large continuous memory, accesses the memory in blocks of a few bytes,  and extracts/sets the bits with bit operations like bit masking and bit  shifting.</p>
<p>Because of that there is a certain overhead when you read or write bits with a <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code>, and quite often using a <code class="docutils literal notranslate"><span class="pre">vector&lt;char&gt;</span></code> (which uses 1 byte for each entry, so 8x the amount of memory) is faster.</p>
<p>However, for the simple implementations of the Sieve of Eratosthenes using a <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> is faster. You are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage. A benchmark (<a class="reference external" href="https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e">link</a>) shows, that using a <code class="docutils literal notranslate"><span class="pre">vector&lt;bool&gt;</span></code> is between 1.4x and 1.7x faster than using a <code class="docutils literal notranslate"><span class="pre">vector&lt;char&gt;</span></code>.</p>
</section>
</section>
<section id="segmented-sieve">
<h3>Segmented Sieve<a class="headerlink" href="#segmented-sieve" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">count_primes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">primes</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nsqrt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">is_prime</span><span class="p">(</span><span class="n">nsqrt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsqrt</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">primes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsqrt</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fill</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">primes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">start_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">                </span><span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">                </span><span class="n">result</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="find-primes-in-range">
<h3>Find primes in range<a class="headerlink" href="#find-primes-in-range" title="Link to this heading"></a></h3>
<p>Sometimes we need to find all prime numbers in a range [<em>L</em>,<em>R</em>] of small size (e.g. <em>R</em>−<em>L</em>+1≈1<em>e</em>7), where <em>R</em> can be very large (e.g. 1<em>e</em>12).</p>
<p>To solve such a problem, we can use the idea of the Segmented sieve. We pre-generate all prime numbers up to <span class="math notranslate nohighlight">\(\sqrt(R)\)</span>​​, and use those primes to mark all composite numbers in the segment [<em>L</em>,<em>R</em>].</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// (R-L+1) log log R + sqrt(R) log log sqrt(R)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">segmentedSieve</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// generate all primes up to sqrt(R)</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">lim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mark</span><span class="p">(</span><span class="n">lim</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">primes</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">lim</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">primes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">lim</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="n">mark</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">isPrime</span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">primes</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="n">isPrime</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">L</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">isPrime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">isPrime</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s also possible that we don’t pre-generate all prime numbers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// (R-L+1) log R + \sqrt(R)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">segmentedSieveNoPreGen</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">isPrime</span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">lim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">lim</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="n">isPrime</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">L</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">isPrime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">isPrime</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="sieve-of-eratosthenes-having-linear-time-complexity">
<h2>Sieve of Eratosthenes Having Linear Time Complexity<a class="headerlink" href="#sieve-of-eratosthenes-having-linear-time-complexity" title="Link to this heading"></a></h2>
<p>This will also calculate the factorization of all numbers smaller than <span class="math notranslate nohighlight">\(N\)</span>, which is useful in many cases.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000000</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">lp</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pr</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">pr</span><span class="p">.</span><span class="n">push_back</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">pr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">        </span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pr</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can speed it up a bit by replacing vector <em>p**r</em> with a simple array and a counter, and by getting rid of the second multiplication in the nested <code class="docutils literal notranslate"><span class="pre">for</span></code> loop (for that we just need to remember the product in a variable).</p>
<section id="correctness-proof">
<h3>Correctness Proof<a class="headerlink" href="#correctness-proof" title="Link to this heading"></a></h3>
<p>We need to prove that the algorithm sets all values <span class="math notranslate nohighlight">\(l p[]\)</span> correctly, and that every value will be set exactly once. Hence, the  algorithm will have linear runtime, since all the remaining actions of  the algorithm, obviously, work for <em>O</em>(<em>n</em>).</p>
<p>Notice that every number <span class="math notranslate nohighlight">\(i\)</span> has exactly one representation in form: <span class="math notranslate nohighlight">\(i= lp[i] * x\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(lp[i]\)</span> is the minimal prime factor of <em>i</em>, and the number <em>x</em> doesn’t have any prime factors less than <em>l**p</em>[<em>i</em>] , i.e.<span class="math notranslate nohighlight">\(lp[i] \le x\)</span>.</p>
<p>Now, let’s compare this with the actions of our algorithm: in fact, for every <span class="math notranslate nohighlight">\(x\)</span>  it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to <span class="math notranslate nohighlight">\(lp[x]\)</span>​​  inclusive, in order to get the numbers in the form given above.</p>
<p>Hence, the algorithm will go through every composite number exactly once, setting the correct values <span class="math notranslate nohighlight">\(lp[]\)</span>​​ there. Q.E.D.</p>
</section>
</section>
<section id="primality-tests">
<h2>Primality tests<a class="headerlink" href="#primality-tests" title="Link to this heading"></a></h2>
<section id="trial-division">
<h3>Trial division<a class="headerlink" href="#trial-division" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isPrime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fermat-primality-test">
<h3>Fermat primality test<a class="headerlink" href="#fermat-primality-test" title="Link to this heading"></a></h3>
<p>This is a probabilistic test.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^{p-1} \equiv 1 \mod p$$ if p is prime. If inequality discovered for $a$, call it *Fermat witness*. If equality discovered for $a$, but p is not prime, then call it *Fermat liar*.\\```c++
bool probablyPrimeFermat(int n, int iter=5) {
    if (n &lt; 4)
        return n == 2 || n == 3;\\    for (int i = 0; i &lt; iter; i++) {
        int a = 2 + rand() % (n - 3);
        if (binpower(a, n - 1, n) != 1)
            return false;
    }
    return true;
}
```\\Use binary exponentiation to obtain runtime $c \log n$.\\There is one bad news though: there exist some composite numbers where $$a^{p-1} \equiv 1 \mod p$$​ holds for holds for all *a* coprime to *n*, called *Carmichael numbers*. The Fermat primality test can identify these numbers only, if we have immense luck and choose a base *a* with gcd(*a*,*n*)≠1.\\### Miller-Rabin primality test\\For an odd number *n*, *n*−1 is even and we can factor out all powers of 2. We can write:\\$$n-1=2^s \cdot d$$, with $d$​ odd.\\This allows us to factorize the equation of Fermat's little theorem:\\$$(a^{2^{s-1}d}+1)(a^{2^{s-2}d}+1) \cdots (a^d + 1)(a^d - 1) \equiv 0 \mod n$$​​\\If *n* is prime, then *n* has to divide one of these factors. And in the Miller-Rabin primality test we check exactly that statement,  which is a more stricter version of the statement of the Fermat test. For a base 2≤*a*≤*n*−2 we check if either\\$$a^d \equiv 1 \mod n\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^{2^r d} \equiv -1 \mod n$$ for some $0 \le r \le s-1$​.\\If we found a base *a* which doesn't satisfy any of the above equalities, than we found a *witness* for the compositeness of *n*. In this case we have proven that *n* is not a prime number.\\Similar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number. In that case the base *a* is called a *strong liar*. If a base *a* satisfies the equations (one of them), *n* is only *strong probable prime*. However, there are no numbers like the Carmichael numbers, where all non-trivial bases lie. In fact it is possible to show, that at most 1/4 of the bases can be strong liars. If *n* is composite, we have a probability of ≥75% that a random base will tell us that it is composite. By doing multiple iterations, choosing different random bases, we can  tell with very high probability if the number is truly prime or if it is composite.\\Miller showed that it is possible to make the algorithm deterministic by only checking all bases $≤O(( \ln n)^2)$​​​. Bach later gave a concrete bound, it is only necessary to test all bases $a \le 2 ( \ln n )^2$​​​​\\This is still a pretty large number of bases. So people have invested quite a lot of computation power into finding lower bounds. It turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7. The smallest composite number that fails this test is 3,215,031,751=151⋅751⋅28351\\. And for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.\\```c++
using u64 = uint64_t;
using u128 = __uint128_t;\\u64 binpower(u64 base, u64 e, u64 mod) {
    u64 result = 1;
    base %= mod;
    while (e) {
        if (e &amp; 1)
            result = (u128)result * base % mod;
        base = (u128)base * base % mod;
        e &gt;&gt;= 1;
    }
    return result;
}\\bool check_composite(u64 n, u64 a, u64 d, int s) {
    u64 x = binpower(a, d, n);
    if (x == 1 || x == n - 1)
        return false;
    for (int r = 1; r &lt; s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1)
            return false;
    }
    return true;
};\\// deterministic version
bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.
    if (n &lt; 2)
        return false;\\    int r = 0;
    u64 d = n - 1;
    while ((d &amp; 1) == 0) {
        d &gt;&gt;= 1;
        r++;
    }\\    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)
            return true;
        if (check_composite(n, a, d, r))
            return false;
    }
    return true;
}
```\\## Integer factorization\\Notice, if the number that you want to factorize is actually a prime  number, most of the algorithms, especially Fermat's factorization  algorithm, Pollard's p-1, Pollard's rho algorithm will run very slow. So it makes sense to perform a probabilistic (or a fast deterministic) primality test before trying to factorize the number.\\### Trial division\\```c++
vector&lt;long long&gt; trial_division1(long long n) {
    vector&lt;long long&gt; factorization;
    for (long long d = 2; d * d &lt;= n; d++) {
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
    }
    if (n &gt; 1)
        factorization.push_back(n);
    return factorization;
}
```\\### Wheel factorization\\This is an optimization of the trial division. The idea is the following. Once we know that the number is not divisible by 2, we don't need to check every other even number. This leaves us with only 50% of the numbers to check. After checking 2, we can simply start with 3 and skip every other number.\\```c++
vector&lt;long long&gt; trial_division2(long long n) {
    vector&lt;long long&gt; factorization;
    while (n % 2 == 0) {
        factorization.push_back(2);
        n /= 2;
    }
    for (long long d = 3; d * d &lt;= n; d += 2) {
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
    }
    if (n &gt; 1)
        factorization.push_back(n);
    return factorization;
}
```\\This method can be extended. If the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations. So we only need to check the numbers 5,7,11,13,17,19,23,…. We can observe a pattern of these remaining numbers. We need to check all numbers with *d*mod6=1 and *d*mod6=5. So this leaves us with only 33.3%\\ percent of the numbers to check. We can implement this by checking the primes 2 and 3 first, and then  start checking with 5 and alternatively skip 1 or 3 numbers.\\We can extend this even further. Here is an implementation for the prime number 2, 3 and 5. It's convenient to use an array to store how much we have to skip.\\```cpp
vector&lt;long long&gt; trial_division3(long long n) {
    vector&lt;long long&gt; factorization;
    for (int d : {2, 3, 5}) {
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
    }
    static array&lt;int, 8&gt; increments = {4, 2, 4, 2, 4, 6, 2, 6};
    int i = 0;
    for (long long d = 7; d * d &lt;= n; d += increments[i++]) {
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
        if (i == 8)
            i = 0;
    }
    if (n &gt; 1)
        factorization.push_back(n);
    return factorization;
}
```\\### Precomputed primes\\Extending the wheel factorization with more and more primes will leave exactly the primes to check. So a good way of checking is just to precompute all prime numbers with the [Sieve of Eratosthenes](https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html) until $\sqrt{n}$ and test them individually.\\```c++
vector&lt;long long&gt; primes;\\vector&lt;long long&gt; trial_division4(long long n) {
    vector&lt;long long&gt; factorization;
    for (long long d : primes) {
        if (d * d &gt; n)
            break;
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
    }
    if (n &gt; 1)
        factorization.push_back(n);
    return factorization;
}
```\\### Fermat's factorization method\\We can write an odd composite number *n*=*p*⋅*q* as the difference of two squares $$n = (\frac{p+q}{2})^2 - (\frac{p-q}{2})^2$$.\\```c++
int fermat(int n) {
    int a = ceil(sqrt(n));
    int b2 = a*a - n;
    int b = round(sqrt(b2));
    while (b * b != b2) {
        a = a + 1;
        b2 = a*a - n;
        b = round(sqrt(b2));
    }
    return a - b;
}
```\\Notice, this factorization method can be very fast, if the difference between the two factors *p* and *q* is small. The algorithm runs in *O*(|*p*−*q*|) time. However since it is very slow, once the factors are far apart, it is rarely used in practice.\\### Pollard's *p*−1 method\\not understanded\\## Pollard's rho algorithm\\Generate sudo random sequence $\{x_0, x_1, ...\}$, and take $\mod n$​​. We try to find two $g = gcd(x_s - x_t , n) &gt; 0$​​. Equivalently, we have found a cycle in the sequence $\mod g$​. This gives $g$ If $&lt; n$​​ a factor. The expected run-time before a cycle appears is $O(n^{1/4})$.\\### Floyd's cycle-finding algorithm\\If the cycle length is *λ* and the *μ* is the first index at which the cycle starts, then the algorithm will run in *O*(*λ*+*μ*) time.\\```c++
long long mult(long long a, long long b, long long mod) {
    return (__int128)a * b % mod;
}\\long long f(long long x, long long c, long long mod) {
    return (mult(x, x, mod) + c) % mod;
}
// expected time O(n^{1/4} * log n)
long long rho(long long n, long long x0=2, long long c=1) {
    long long x = x0;
    long long y = x0;
    long long g = 1;
    while (g == 1) {
        x = f(x, c, n);
        y = f(y, c, n);
        y = f(y, c, n);
        g = gcd(abs(x - y), n);
    }
    return g;
}
```\\### Brent's algorithm\\```c++
long long brent(long long n, long long x0=2, long long c=1) {
    long long x = x0;
    long long g = 1;
    long long q = 1;
    long long xs, y;\\    int m = 128;
    int l = 1;
    while (g == 1) {
        y = x;
        for (int i = 1; i &lt; l; i++)
            x = f(x, c, n);
        int k = 0;
        while (k &lt; l &amp;&amp; g == 1) {
            xs = x;
            for (int i = 0; i &lt; m &amp;&amp; i &lt; l - k; i++) {
                x = f(x, c, n);
                q = mult(q, abs(y - x), n);
            }
            g = gcd(q, n);
            k += m;
        }
        l *= 2;
    }
    if (g == n) {
        do {
            xs = f(xs, c, n);
            g = gcd(abs(xs - y), n);
        } while (g == 1);
    }
    return g;
}
```\\The combination of a trial division for small prime numbers together  with Brent's version of Pollard's rho algorithm will make a very  powerful factorization algorithm.\\## Euler's totient function\\```c++
int phi(int n) {
    int result = n;
    for (int i = 2; i * i &lt;= n; i++) {
        if (n % i == 0) {
            while (n % i == 0)
                n /= i;
            result -= result / i;
        }
    }
    if (n &gt; 1)
        result -= result / n;
    return result;
}
```\\```c++
void phi_1_to_n(int n) {
    vector&lt;int&gt; phi(n + 1);
    phi[0] = 0;
    phi[1] = 1;
    for (int i = 2; i &lt;= n; i++)
        phi[i] = i;\\    for (int i = 2; i &lt;= n; i++) {
        if (phi[i] == i) {
            for (int j = i; j &lt;= n; j += i)
                phi[j] -= phi[j] / i;
        }
    }
}
```\\### Divisor sum property\\$$\sum_{d | n} \phi(d) = n\end{aligned}\end{align} \]</div>
</section>
<section id="euler-s-theorem">
<h3>Euler’s Theorem<a class="headerlink" href="#euler-s-theorem" title="Link to this heading"></a></h3>
<p>If a and m are relatively prime, then <span class="math notranslate nohighlight">\(a^{\phi(m)} \equiv 1 \pmod{m}\)</span>​</p>
<p>Results</p>
<p><span class="math notranslate nohighlight">\(a^n = a^{n \mod{\phi(m)}} \pmod m\)</span></p>
<p>For arbitrary x,m (not coprime), <span class="math notranslate nohighlight">\(x^n \equiv x^{\phi(m) + [n \mod \phi(m)]} \pmod m\)</span>​</p>
</section>
</section>
<section id="find-modulo-inverse">
<h2>Find Modulo Inverse<a class="headerlink" href="#find-modulo-inverse" title="Link to this heading"></a></h2>
<section id="extended-euclidean-algo">
<h3>Extended Euclidean Algo<a class="headerlink" href="#extended-euclidean-algo" title="Link to this heading"></a></h3>
<p><span class="math notranslate nohighlight">\(ax+my=1\)</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extended_euclidean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No solution!&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fermat-s-euclid-thm">
<h3>Fermat’s / Euclid Thm<a class="headerlink" href="#fermat-s-euclid-thm" title="Link to this heading"></a></h3>
<p><span class="math notranslate nohighlight">\(a^{\phi(m)} \equiv 1 \pmod m\)</span></p>
<p><span class="math notranslate nohighlight">\(a^{\phi(m)-1} \equiv a^{-1} \pmod m\)</span>​</p>
<p>Both of the above are <span class="math notranslate nohighlight">\(O(\log n)\)</span>.</p>
</section>
<section id="find-all-number-s-modulo-inverse-from-1-to-m-in-o-m">
<h3>Find all number’s modulo inverse from 1 to m in <span class="math notranslate nohighlight">\(O(m)\)</span>​<a class="headerlink" href="#find-all-number-s-modulo-inverse-from-1-to-m-in-o-m" title="Link to this heading"></a></h3>
<p><span class="math notranslate nohighlight">\(inv(i) = - \lfloor \frac{m}{i} \rfloor \cdot inv(m \mod i) \pmod m\)</span>​</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inv</span><span class="p">[</span><span class="n">m</span><span class="o">%</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="linear-congruence-equation">
<h2>Linear Congruence Equation<a class="headerlink" href="#linear-congruence-equation" title="Link to this heading"></a></h2>
<p><span class="math notranslate nohighlight">\(ax \equiv b \pmod m\)</span></p>
<section id="inverse">
<h3>Inverse<a class="headerlink" href="#inverse" title="Link to this heading"></a></h3>
<p>let <span class="math notranslate nohighlight">\(g = gcd(a,m)\)</span></p>
<p>if g does not divides b, no solution.</p>
<p>Otherwise, obtain <span class="math notranslate nohighlight">\(a'x' \equiv b' \pmod m'\)</span>​ where <span class="math notranslate nohighlight">\(gcd(a',m') = 1\)</span>​​.​</p>
<p><span class="math notranslate nohighlight">\(x'\)</span> will be a solution, but there are other solutions, <span class="math notranslate nohighlight">\(x_i = x' + i \cdot n'\)</span> for <span class="math notranslate nohighlight">\(i = 0, ..., g-1\)</span>.</p>
</section>
<section id="extended-euclidean-algorithm">
<h3>Extended Euclidean Algorithm<a class="headerlink" href="#extended-euclidean-algorithm" title="Link to this heading"></a></h3>
<p><span class="math notranslate nohighlight">\(ax + my = b\)</span>​​</p>
</section>
</section>
<section id="chinese-remainder-theorem">
<h2>Chinese Remainder Theorem<a class="headerlink" href="#chinese-remainder-theorem" title="Link to this heading"></a></h2>
<p>let <span class="math notranslate nohighlight">\(p = p_1 p_2 ... p_k\)</span>​, where <span class="math notranslate nohighlight">\(p_i\)</span>​ are relatively prime, and <span class="math notranslate nohighlight">\(a \equiv a_i \pmod p_i\)</span>​​. Then, there is exactly one solution <span class="math notranslate nohighlight">\(a \pmod p\)</span>.</p>
<section id="garner-s-algorithm">
<h3>Garner’s Algorithm<a class="headerlink" href="#garner-s-algorithm" title="Link to this heading"></a></h3>
<p>mixed radix representation of a is</p>
<p><span class="math notranslate nohighlight">\(a = x_1 + x_2 p_1 + x_3 p_1 p_2 + ... + x_k p_1 ...p_{k-1}\)</span></p>
<p>Let <span class="math notranslate nohighlight">\(r_{ij} = (p_i)^{-1} \pmod p_j\)</span> by prev algorithm, thus</p>
<p><span class="math notranslate nohighlight">\(a_1 \equiv x_1 \pmod {p_1}\)</span>​</p>
<p><span class="math notranslate nohighlight">\(a_2 \equiv x_1+x_1p_1 \pmod {p_2}\)</span>​</p>
<p><span class="math notranslate nohighlight">\(x_2 \equiv (a_2 - x_1)r_{12} \pmod {p_2}\)</span></p>
<p>Thus <span class="math notranslate nohighlight">\(x_3 \equiv ((a_3-x_1)r_{13} - x_2)r_{23} \pmod {p_3}\)</span></p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">);</span>

<span class="w">        </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="discrete-logarithm">
<h2>Discrete Logarithm<a class="headerlink" href="#discrete-logarithm" title="Link to this heading"></a></h2>
<p>The discrete logarithm is an integer <em>x</em> satisfying the equation <span class="math notranslate nohighlight">\(a^x \equiv b \pmod m\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(m\)</span> are relatively prime.</p>
<p>Let <span class="math notranslate nohighlight">\(x = np-q\)</span>. then any number <span class="math notranslate nohighlight">\(x \in [0,m)\)</span> can be represented in this form, <span class="math notranslate nohighlight">\(p \in [1, \lceil \frac{m}{n} \rceil]\)</span>, <span class="math notranslate nohighlight">\(q \in [0,n]\)</span></p>
<p>So <span class="math notranslate nohighlight">\(a^{np} \equiv b a^{q} \pmod m\)</span>.</p>
<p>This problem can be solved using the meet-in-the-middle method as follows:</p>
<ul class="simple">
<li><p>Calculate <em>f</em>1 for all possible arguments <em>p</em>. Sort the array of value-argument pairs.</p></li>
<li><p>For all possible arguments <em>q</em>, calculate <em>f</em>2 and look for the corresponding <em>p</em> in the sorted array using binary search.</p></li>
</ul>
<p>First step : <span class="math notranslate nohighlight">\(O(\frac{m}{n} \log m)\)</span>, Second Step : <span class="math notranslate nohighlight">\(O(n \log m)\)</span>. We can choose <span class="math notranslate nohighlight">\(n = \sqrt m\)</span> to minimize this to get <span class="math notranslate nohighlight">\(O(\sqrt m \log m)\)</span>.</p>
<section id="the-simplest-implementation">
<h3>The simplest implementation<a class="headerlink" href="#the-simplest-implementation" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">powmod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vals</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">p</span><span class="p">)</span>
<span class="w">        </span><span class="n">vals</span><span class="p">[</span><span class="n">powmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">powmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vals</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="improved-implementation">
<h3>Improved implementation<a class="headerlink" href="#improved-implementation" title="Link to this heading"></a></h3>
<p>A possible improvement is to get rid of binary exponentiation. This can be done by keeping a variable that is multiplied by <em>a</em> each time we increase <em>q</em> and a variable that is multiplied by <em>a**n</em> each time we increase <em>p</em>. With this change, the complexity of the algorithm is still the same, but now the log factor is only for the <code class="docutils literal notranslate"><span class="pre">map</span></code>. Instead of a <code class="docutils literal notranslate"><span class="pre">map</span></code>, we can also use a hash table (<code class="docutils literal notranslate"><span class="pre">unordered_map</span></code> in C++) which has the average time complexity <em>O</em>(1) for inserting and searching.</p>
<p>Problems often ask for the minimum <em>x</em> which satisfies the solution. It is possible to get all answers and take the minimum, or reduce the first found answer using <a class="reference external" href="https://cp-algorithms.com/algebra/phi-function.html#toc-tgt-2">Euler’s theorem</a>, but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns minimum x for which a ^ x % m = b % m, a and m are coprime.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">an</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">an</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vals</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vals</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">an</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vals</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vals</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="when-a-and-m-are-not-coprime">
<h3>When <em>a</em> and <em>m</em> are not coprime<a class="headerlink" href="#when-a-and-m-are-not-coprime" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns minimum x for which a ^ x % m = b % m.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">add</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">add</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">an</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">an</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vals</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vals</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1l</span><span class="n">l</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">an</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vals</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vals</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">add</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="primitive-root">
<h2>Primitive Root<a class="headerlink" href="#primitive-root" title="Link to this heading"></a></h2>
<p>In modular arithmetic, a number <em>g</em> is called a <code class="docutils literal notranslate"><span class="pre">primitive</span> <span class="pre">root</span> <span class="pre">modulo</span> <span class="pre">n</span></code> if every number coprime to <em>n</em> is congruent to a power of <em>g</em> modulo <em>n</em>. Mathematically, <em>g</em> is a <code class="docutils literal notranslate"><span class="pre">primitive</span> <span class="pre">root</span> <span class="pre">modulo</span> <span class="pre">n</span></code> if and only if for any integer <em>a</em> such that gcd(<em>a</em>,<em>n</em>)=1, there exists an integer <em>k</em> such that:<em>g**k</em>≡<em>a</em>(mod<em>n</em>).<em>k</em> is then called the <code class="docutils literal notranslate"><span class="pre">index</span></code> or <code class="docutils literal notranslate"><span class="pre">discrete</span> <span class="pre">logarithm</span></code> of <em>a</em> to the base <em>g</em> modulo <em>n</em>. <em>g</em> is also called the <code class="docutils literal notranslate"><span class="pre">generator</span></code> of the multiplicative group of integers modulo <em>n</em>.</p>
<p>In particular, for the case where <em>n</em> is a prime, the powers of primitive root runs through all numbers from 1 to <em>n</em>−1.</p>
<section id="existence">
<h3>Existence<a class="headerlink" href="#existence" title="Link to this heading"></a></h3>
<p>Primitive root modulo <em>n</em> exists if and only if:</p>
<ul class="simple">
<li><p><em>n</em> is 1, 2, 4, or</p></li>
<li><p><em>n</em> is power of an odd prime number (<em>n</em>=<em>p**k</em>), or</p></li>
<li><p><em>n</em> is twice power of an odd prime number (<em>n</em>=2⋅<em>p**k</em>).</p></li>
</ul>
</section>
<section id="relation-with-the-euler-function">
<h3>Relation with the Euler function<a class="headerlink" href="#relation-with-the-euler-function" title="Link to this heading"></a></h3>
<p>Let <em>g</em> be a primitive root modulo <em>n</em>. Then we can show that the smallest number <em>k</em> for which <em>g**k</em>≡1(mod<em>n</em>) is equal <em>ϕ</em>(<em>n</em>). Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root.</p>
<p>Furthermore, the number of primitive roots modulo <em>n</em>, if there are any, is equal to <em>ϕ</em>(<em>ϕ</em>(<em>n</em>)).</p>
</section>
<section id="computation">
<h3>Computation<a class="headerlink" href="#computation" title="Link to this heading"></a></h3>
<p>don’t understand</p>
</section>
</section>
<section id="discrete-root">
<h2>Discrete Root<a class="headerlink" href="#discrete-root" title="Link to this heading"></a></h2>
<p>don’t understand</p>
</section>
<section id="montgomery-multiplication">
<h2>Montgomery Multiplication<a class="headerlink" href="#montgomery-multiplication" title="Link to this heading"></a></h2>
<p>The <strong>Montgomery (modular) multiplication</strong> is a method that allows computing such multiplications <span class="math notranslate nohighlight">\(ab \mod n\)</span>​ faster. Instead of dividing the product and subtracting <em>n</em> multiple times, it adds multiples of <em>n</em> to cancel out the lower bits and then just discards the lower bits.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<p>https://cp-algorithms.com/</p>
</section>
</section>

<div class="section ablog__blog_comments">
     
<div class="section ablog__prev-next">
  <span class="ablog__prev">
    
  </span>
  <span class="ablog__spacer">&nbsp;</span>
  <span class="ablog__next">
      Next: 
    <a href="../tech/notes_c.html">
      <span>C language Notes</span>
      
    </a>
    
  </span>
</div>
  
</div>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="combinatorics.html" class="btn btn-neutral float-right" title="Combinatorics Algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Zhaocheng Che, chezhaocheng[AT]outlook.com.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>