

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MsgBox In-place Serializer in Rust &mdash; Zhaocheng Che&#39;s Blog 2025-11-26 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3d3e70f0"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="C language Notes" href="notes_c.html" />
    <link rel="prev" title="Dataloader is Blocking" href="graphql-dataloader.html" />     
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Zhaocheng Che's Blog
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Blog</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tech Posts</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="graphql-dataloader.html">Dataloader is Blocking</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MsgBox In-place Serializer in Rust</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rust-wrapper-api">Rust Wrapper API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-send">Implementation - Send</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-receive">Implementation - Receive</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-about-alignment">More about Alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-improvements">Further Improvements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#more-compact-attachedarray">More Compact <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-accessible-sendctx">More Accessible <code class="docutils literal notranslate"><span class="pre">SendCtx</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="notes_c.html">C language Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../algo/index.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../recap/index.html">Recap</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Zhaocheng Che's Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tech Posts</a></li>
      <li class="breadcrumb-item active">MsgBox In-place Serializer in Rust</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/posts/tech/msgbox.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
              <section class="tex2jax_ignore mathjax_ignore" id="msgbox-in-place-serializer-in-rust">
<h1>MsgBox In-place Serializer in Rust<a class="headerlink" href="#msgbox-in-place-serializer-in-rust" title="Link to this heading"></a></h1>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading"></a></h2>
<p>During my course work for CS452 at the University of Waterloo, in a group of two, we developed our own bare metal real time operating system in C. Our OS runs on the a raspberry pi 4b, which controls a toy train set which receives train/switch command and sends sensor signal over RS232.</p>
<p>With the limited time of course work, the compilation and linking for the OS is very simple. Every C file, regardless if it is in kernel space, user space, or even shared, is linked together. So although the correct way to invoke kernel code is via syscall, nothing prevents a user program to call a kernel function directly. This is unsafe.</p>
<p>In addition, this design also doesn’t go in sync with a functionality that I wanted: load user space programs from external binary.</p>
<p>Therefore, after graduation, I started to add more functionality to the OS. Firstly, I added a very simple loader that only process <code class="docutils literal notranslate"><span class="pre">R_AARCH64_RELATIV</span></code> relocation, which is sufficient to support loading a pie binary that does not contain dynamic library. After that, I wanted to write rust code for user space program. Now, straight forwardly, I can compile the rust code into a pie binary and the OS can execute it without even knowing I wrote rust.</p>
<p>The OS has only one IPC mechanism: message passing. Specifically, three syscalls</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">	One process call ke_send with two buffers.</span>
<span class="cm">	msg buffer contains the bytes to send.</span>
<span class="cm">	reply buffer will be populated with the bytes sent via ke_reply.</span>
<span class="cm">*/</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">ke_send</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">msglen</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">reply</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rplen</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">	One process call ke_recv with one buffer.</span>
<span class="cm">	msg buffer will be populated with the bytes sent via ke_send.</span>
<span class="cm">*/</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">ke_recv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">msglen</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">	One process can call ke_reply after ke_recv returns.</span>
<span class="cm">	reply buffer contains the bytes to send.</span>
<span class="cm">*/</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">ke_reply</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">reply</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rplen</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sender</p></th>
<th class="head"><p></p></th>
<th class="head"><p>Receiver</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p></p></td>
<td><p></p></td>
<td><p>ke_recv()</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p></p></td>
<td><p>(blocked)</p></td>
</tr>
<tr class="row-even"><td><p>ke_send()</p></td>
<td><p>→</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>(blocked)</p></td>
<td><p></p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>←</p></td>
<td><p>ke_reply()</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p></p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
<p>The OS syscall, out of simplicity, only deal with bytes. But to use this functionality efficiently in Rust, I need a wrapper that can convert information in Rust into bytes efficiently. And that Rust information, likely, is coded in a struct.</p>
<p>Note, we are working under the constraint of 1) <code class="docutils literal notranslate"><span class="pre">no_std</span></code>, 2) no heap allocation.</p>
<p>The actual code resides in my <a class="reference external" href="https://github.com/Darwin-Che/trains-os/" title="Trains OS GitHub">TrainsOS</a> project, with <a class="reference external" href="https://github.com/Darwin-Che/trains-os/blob/main/pie-rust/src/sys/msgbox.rs" title="MsgBox Definitions">one file</a> containing the MsgBox implementation, and <a class="reference external" href="https://github.com/Darwin-Che/trains-os/blob/main/pie-rust/deps/msgbox_macro/src/lib.rs" title="MsgBox Macros">another file</a> containing the Rust Macros to generate some generic functions.</p>
</section>
<section id="rust-wrapper-api">
<h2>Rust Wrapper API<a class="headerlink" href="#rust-wrapper-api" title="Link to this heading"></a></h2>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MsgA</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span>
<span class="w">	</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">10</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MsgB</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span>
<span class="w">	</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">AttachedArray</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">RecvEnum</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">MsgA</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">MsgA</span><span class="p">),</span>
<span class="w">	</span><span class="n">MsgB</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">MsgB</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">send_a</span><span class="p">(</span><span class="n">tid</span><span class="p">:</span><span class="w"> </span><span class="nc">Tid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">send_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Rent the bytes in send_buf to use msg_a to write the data in correct place</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">msg_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_prepare</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgA</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">send_buf</span><span class="p">);</span>
<span class="w">	</span><span class="n">msg_a</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">msg_a</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ker_send</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Interpret the bytes in reply_buf,</span>
<span class="w">	</span><span class="c1">// from_recv_bytes() will decide the type of the received message</span>
<span class="w">	</span><span class="c1">// msg_a or msg_b will be renting the bytes in reply_buf, so that</span>
<span class="w">	</span><span class="c1">//   we can read the data in the correct place</span>
<span class="w">	</span><span class="k">match</span><span class="w"> </span><span class="n">from_recv_bytes</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RecvEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgA</span><span class="p">(</span><span class="n">msg_a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span>
<span class="w">		</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgB</span><span class="p">(</span><span class="n">msg_b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">recv_a_or_b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ker_recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Interpret the bytes in recv_buf</span>
<span class="w">	</span><span class="k">match</span><span class="w"> </span><span class="n">from_recv_bytes</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RecvEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgA</span><span class="p">(</span><span class="n">msg_a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span>
<span class="w">		</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgB</span><span class="p">(</span><span class="n">msg_b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Construct the reply</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">msg_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_prepare</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgA</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">);</span>
<span class="w">	</span><span class="n">msg_a</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">msg_a</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ker_reply</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reply_buf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>I actually didn’t use <code class="docutils literal notranslate"><span class="pre">MsgB</span></code> in the above example. <code class="docutils literal notranslate"><span class="pre">MsgB</span></code> contains an <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code>. I define <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code> as a way to send dynamic sized array in a message. The bytes layout in the buffer is like this (with necessary padding between blocks)</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Type ID</p></th>
<th class="head"><p>struct bytes</p></th>
<th class="head"><p>AttachedArray 1</p></th>
<th class="head"><p>(Other AttachedArrays)</p></th>
</tr>
</thead>
</table>
<p><code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code> will act as a reference to the actual attached bytes. It acts like a Rust reference when reading/writing the message. It encodes the relative offset and size in the whole message when transmitting the message across user programs.</p>
<p>Therefore, the complete API looks like this</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MsgA</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span>
<span class="w">	</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">10</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MsgB</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span>
<span class="w">	</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">AttachedArray</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">RecvEnum</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">MsgA</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">MsgA</span><span class="p">),</span>
<span class="w">	</span><span class="n">MsgB</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">MsgB</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">send_a</span><span class="p">(</span><span class="n">tid</span><span class="p">:</span><span class="w"> </span><span class="nc">Tid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">send_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Rent the bytes in send_buf to use MsgA layout to write the data in correct place</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">send_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_prepare</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgA</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">send_buf</span><span class="p">);</span>
<span class="w">	</span><span class="n">send_ctx</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">send_ctx</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ker_send</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Interpret the bytes in reply_buf,</span>
<span class="w">	</span><span class="c1">// from_recv_bytes() will decide the type of the received message</span>
<span class="w">	</span><span class="c1">// msg_a or msg_b will be renting the bytes in reply_buf, so that</span>
<span class="w">	</span><span class="c1">//   we can read the data in the correct place</span>
<span class="w">	</span><span class="k">match</span><span class="w"> </span><span class="n">from_recv_bytes</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RecvEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgA</span><span class="p">(</span><span class="n">msg_a</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="n">msg_a</span><span class="p">),</span>
<span class="w">		</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgB</span><span class="p">(</span><span class="n">msg_b</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="n">msg_b</span><span class="p">),</span>
<span class="w">		</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(),</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">recv_a_or_b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ker_recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Interpret the bytes in recv_buf</span>
<span class="w">	</span><span class="k">match</span><span class="w"> </span><span class="n">from_recv_bytes</span><span class="p">::</span><span class="o">&lt;</span><span class="n">RecvEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgA</span><span class="p">(</span><span class="n">msg_a</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="n">msg_a</span><span class="p">),</span>
<span class="w">		</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgB</span><span class="p">(</span><span class="n">msg_b</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="n">msg_b</span><span class="p">),</span>
<span class="w">		</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(),</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Construct the reply</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">128</span><span class="p">];</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">send_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_prepare</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgB</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">);</span>
<span class="w">	</span><span class="n">send_ctx</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>
<span class="w">	</span><span class="n">send_ctx</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_ctx</span><span class="p">.</span><span class="n">attach_array</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">send_ctx</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">ker_reply</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reply_buf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only change is to introduce <code class="docutils literal notranslate"><span class="pre">send_ctx</span></code>. It should be a wrapper on the raw bytes to present the struct and it should be able to allocate attach array from the raw bytes.</p>
</section>
<section id="implementation-send">
<h2>Implementation - Send<a class="headerlink" href="#implementation-send" title="Link to this heading"></a></h2>
<p>On the sender, we need to implement the API <code class="docutils literal notranslate"><span class="pre">send_ctx</span></code>, <code class="docutils literal notranslate"><span class="pre">attach_array</span></code>, and <code class="docutils literal notranslate"><span class="pre">send_prepare</span></code>.</p>
<p>We first define the struct</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">SendCtx</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">            </span><span class="c1">// The msg struct</span>
<span class="w">		</span><span class="n">send_buf</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w">  </span><span class="c1">// Trailing bytes in the buffer for attached array allocation</span>
<span class="w">		</span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">      </span><span class="c1">// Track usage of the original buffer, i.e. the offset of send_buf</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AttachedArray</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">cnt</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">array</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code> can be created naturally from <code class="docutils literal notranslate"><span class="pre">send_buf</span></code> in <code class="docutils literal notranslate"><span class="pre">SendCtx</span></code>.
(I will skip the distracting details by using macro helper functions with explanatory names)</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl SendCtx&lt;&#39;a, T&gt;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">attach_array</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">AttachedArray</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate padding for alignment of type I</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">aligned_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_aligned_idx</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">align_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">padding_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aligned_idx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">idx</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Check if there is enough space</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">there_is_enough_space</span><span class="o">!</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">send_buf</span><span class="p">,</span><span class="w"> </span><span class="n">aligned_idx</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Split the buffer at new idx</span>
<span class="w">    </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">idx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">padding_len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>

<span class="w">	</span><span class="c1">// Need to use mem::take to remove the life time connection between the attached array and self</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">send_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="p">::</span><span class="n">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">send_buf</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_padding</span><span class="p">,</span><span class="w"> </span><span class="n">send_buf_after_padding</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_buf</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">padding_len</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">send_buf_after_array</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_buf_after_padding</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">cnt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">send_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send_buf_after_array</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Return the AttachedArray</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">AttachedArray</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">idx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">cnt</span><span class="p">:</span><span class="w"> </span><span class="nc">cnt</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">array</span><span class="p">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">unsafe</span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">slice</span><span class="p">::</span><span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">)</span>
<span class="w">        </span><span class="p">}),</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, let’s try to implement <code class="docutils literal notranslate"><span class="pre">send_prepare</span></code>. If we switch perspective, it looks more like a constructor for <code class="docutils literal notranslate"><span class="pre">SendCtx</span></code> instead of a global function.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl SendCtx&lt;&#39;a, T&gt;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">buf_used</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">msg_id_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calc_id_len</span><span class="o">!</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">buf_id</span><span class="p">,</span><span class="w"> </span><span class="n">buf_rest</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">msg_id_len</span><span class="p">);</span>
<span class="w">	</span><span class="n">write_msg_id</span><span class="o">!</span><span class="p">(</span><span class="n">buf_id</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">);</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">buf_obj</span><span class="p">,</span><span class="w"> </span><span class="n">buf_aa</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf_rest</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">sizeof</span><span class="o">!</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
<span class="w">	</span><span class="o">*</span><span class="n">buf_used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg_id_len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sizeof</span><span class="o">!</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="w">	</span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">buf_obj</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">		</span><span class="n">send_buf</span><span class="p">:</span><span class="w"> </span><span class="nc">buf_aa</span><span class="p">,</span>
<span class="w">		</span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="nc">buf_used</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="implementation-receive">
<h2>Implementation - Receive<a class="headerlink" href="#implementation-receive" title="Link to this heading"></a></h2>
<p>There is only one function to implement: <code class="docutils literal notranslate"><span class="pre">from_recv_bytes</span></code>. It can be described as this: 1) given all the choices in the enum, choose the appropriate variant based on the first segment of the received bytes, 2) interpret the second part of the bytes as the chosen struct, 3) split the third part of the bytes into chunks according to the attached arrays in the struct from part two, 4) assign the attached arrays to the associated fields in the struct.</p>
<p>Notice that we cannot just take the bytes containing all of the attached arrays and in a loop for each attached array fields we take a slice of the bytes and assign it to the attached array fields. The reason is that it violates the singularity of the mutable reference. The Rust compiler doesn’t know if the program could end up having two attached array referencing overlapped bytes. In summary, we have to first find the split positions in the bytes, split it into segments, then assign each segment to the corresponding attached array.</p>
<p>Another thing to note is that in the first step, the function needs to be aware of all the choices in the enum and in the third step, the function needs to know all the attached array fields in a struct. For these purpose, we can use a Rust <code class="docutils literal notranslate"><span class="pre">proc_macro</span></code>. However, here for the simplicity for illustration, I will write specific functions which will be the result of <code class="docutils literal notranslate"><span class="pre">proc_macro</span></code> expansion. Simply keep in mind that the code sometimes looks weird only because <code class="docutils literal notranslate"><span class="pre">proc_macro</span></code> generates it.</p>
<p>Firstly, let me give the implementation of <code class="docutils literal notranslate"><span class="pre">from_recv_bytes</span></code> generated for <code class="docutils literal notranslate"><span class="pre">RecvEnum</span></code> which calls into another <code class="docutils literal notranslate"><span class="pre">from_recv_bytes</span></code> which is a member function generated for each msg struct.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl RecvEnum&lt;&#39;a&gt;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">from_recv_bytes</span><span class="p">(</span><span class="n">buf</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="k">match</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="p">[</span><span class="w"> </span><span class="n">msg_id_with_padding</span><span class="o">!</span><span class="p">(</span><span class="n">MsgA</span><span class="p">),</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">				</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgA</span><span class="p">(</span><span class="n">MsgA</span><span class="p">::</span><span class="n">from_recv_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">))),</span>
<span class="w">		</span><span class="p">[</span><span class="w"> </span><span class="n">msg_id_with_padding</span><span class="o">!</span><span class="p">(</span><span class="n">MsgB</span><span class="p">),</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">				</span><span class="nb">Some</span><span class="p">(</span><span class="n">RecvEnum</span><span class="p">::</span><span class="n">MsgB</span><span class="p">(</span><span class="n">MsgB</span><span class="p">::</span><span class="n">from_recv_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">))),</span>
<span class="w">		</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, let me give the implementation of the member function <code class="docutils literal notranslate"><span class="pre">from_recv_bytes</span></code> where msg struct is interpreted, and it calls <code class="docutils literal notranslate"><span class="pre">from_recv_bytes</span></code> of <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code> to split the bytes and assign the reference. Here I will give the example for <code class="docutils literal notranslate"><span class="pre">MsgB</span></code></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl MsgB&lt;&#39;a&gt;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">from_recv_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">buf_obj</span><span class="p">,</span><span class="w"> </span><span class="n">buf_attached</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="bp">Self</span><span class="p">));</span>
<span class="w">	</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">buf_obj</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">)</span><span class="w"> </span><span class="p">};</span>
<span class="w">	</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">array_fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">];</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">AttachedArray</span><span class="p">::</span><span class="n">from_recv_bytes</span><span class="p">(</span>
<span class="w">		</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">array_fields</span><span class="p">,</span>
<span class="w">		</span><span class="n">buf_attached</span><span class="p">,</span>
<span class="w">		</span><span class="n">msg_id_with_padding_len</span><span class="o">!</span><span class="p">(</span><span class="bp">Self</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="bp">Self</span><span class="p">)</span>
<span class="w">	</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="n">obj</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then there is the implementation of <code class="docutils literal notranslate"><span class="pre">AttachedArray::from_recv_bytes</span></code> which I came up with draining my brain power.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl AttachedArray&lt;&#39;a, I&gt;</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">from_recv_bytes</span><span class="p">(</span><span class="n">ref_array</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="p">],</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">idx_offset</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">ref_array</span><span class="p">.</span><span class="n">sort_unstable_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">aa</span><span class="o">|</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">idx</span><span class="p">);</span>
<span class="w">	</span>
<span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx_offset</span><span class="p">;</span>
<span class="w">	</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">aa</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">ref_array</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">idx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">		</span><span class="c1">// Discard the padding between attached arrays due to alignment</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">			</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">start</span><span class="p">).</span><span class="mi">1</span><span class="p">;</span>
<span class="w">		</span><span class="p">}</span>
<span class="w">		</span>
<span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">split_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">aa</span><span class="p">.</span><span class="n">cnt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="w">		</span><span class="n">aa</span><span class="p">.</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">slice</span><span class="p">::</span><span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">split_buf</span><span class="p">.</span><span class="mf">0.</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span><span class="w"> </span><span class="p">});</span>
<span class="w">		</span>
<span class="w">		</span><span class="c1">// Update the buf to the rest of the array</span>
<span class="w">		</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">split_buf</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
<span class="w">		</span><span class="c1">// Update buf offset with the segment we just cut off</span>
<span class="w">		</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">cnt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span><span class="o">!</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we have most of the code!</p>
</section>
<section id="more-about-alignment">
<h2>More about Alignment<a class="headerlink" href="#more-about-alignment" title="Link to this heading"></a></h2>
<p>In the above implementation, we need to take care of alignment in several places. However, we missed a few places:</p>
<ul class="simple">
<li><p>the actual byte buffer needs to be properly aligned. Therefore, we should modify the raw buffer we used before by wrapping it in a struct that is 8 bytes aligned.</p></li>
<li><p>in addition, the <code class="docutils literal notranslate"><span class="pre">msg_id_with_padding!</span></code> is also always padded to be a multiple of 8 bytes.</p></li>
</ul>
<p>Given the previous two alignment constraint, the actual struct is always on 8 bytes boundary.</p>
</section>
<section id="further-improvements">
<h2>Further Improvements<a class="headerlink" href="#further-improvements" title="Link to this heading"></a></h2>
<section id="more-compact-attachedarray">
<h3>More Compact <code class="docutils literal notranslate"><span class="pre">AttachedArray</span></code><a class="headerlink" href="#more-compact-attachedarray" title="Link to this heading"></a></h3>
<p>If we change the definition from</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AttachedArray</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">cnt</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">array</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[repr(C)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">AttachedArray</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx_cnt</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">isize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span>
<span class="w">    </span><span class="n">array</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We get to save 8 bytes per attached array field; however, we need to modify the functions a little bit.</p>
<ul class="simple">
<li><p>Receive reads <code class="docutils literal notranslate"><span class="pre">idx_cnt</span></code> and overwrites it with <code class="docutils literal notranslate"><span class="pre">array</span></code>.</p></li>
<li><p>Send overwrites array with <code class="docutils literal notranslate"><span class="pre">idx_cnt</span></code> after <code class="docutils literal notranslate"><span class="pre">array</span></code> is filled out and before actually sending the buffer. This can be implemented by using the <code class="docutils literal notranslate"><span class="pre">Drop</span></code> trait for <code class="docutils literal notranslate"><span class="pre">SendCtx</span></code>.</p></li>
</ul>
</section>
<section id="more-accessible-sendctx">
<h3>More Accessible <code class="docutils literal notranslate"><span class="pre">SendCtx</span></code><a class="headerlink" href="#more-accessible-sendctx" title="Link to this heading"></a></h3>
<p>Currently, we need to use <code class="docutils literal notranslate"><span class="pre">send_ctx.t</span></code> to reference the msg struct to send.</p>
<p>We can implement the <code class="docutils literal notranslate"><span class="pre">Deref</span></code> and <code class="docutils literal notranslate"><span class="pre">DerefMut</span></code> trait for <code class="docutils literal notranslate"><span class="pre">send_ctx</span></code> so that we can directly use it</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">msg_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SendCtx</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgB</span><span class="o">&gt;</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">reply_buf</span><span class="p">);</span>
<span class="w">	</span><span class="n">msg_b</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>
<span class="w">	</span><span class="n">msg_b</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg_b</span><span class="p">.</span><span class="n">attach_array</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">msg_b</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
</pre></div>
</div>
<p>Furthermore, if we implement <code class="docutils literal notranslate"><span class="pre">Deref</span></code> and <code class="docutils literal notranslate"><span class="pre">DerefMut</span></code> on <code class="docutils literal notranslate"><span class="pre">AttachArray</span></code>, we will be able to do this</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">msg_b</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="c1">// =&gt;</span>
<span class="n">msg_b</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the syntax is much more concise.</p>
</section>
</section>
</section>

<div class="section ablog__blog_comments">
     
<div class="section ablog__prev-next">
  <span class="ablog__prev">
      Previous:
    
    <a href="../recap/cs452.html">
      
      <span>The CS452 Journey - W23</span>
    </a>
    
  </span>
  <span class="ablog__spacer">&nbsp;</span>
  <span class="ablog__next">
      Next: 
    <a href="graphql-dataloader.html">
      <span>Dataloader is Blocking</span>
      
    </a>
    
  </span>
</div>
  
</div>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="graphql-dataloader.html" class="btn btn-neutral float-left" title="Dataloader is Blocking" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="notes_c.html" class="btn btn-neutral float-right" title="C language Notes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Zhaocheng Che, chezhaocheng[AT]outlook.com.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>